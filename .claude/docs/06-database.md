# Baza Danych i Migracje

## Architektura Bazy Danych

### Struktura Schematów

Projekt wykorzystuje **dwa schematy PostgreSQL**:

1. **`content` schema** - Dane główne (master data), zarządzane przez administratorów
   - `ingredients` - Słownik składników z wartościami odżywczymi
   - `recipes` - Przepisy na posiłki
   - `recipe_ingredients` - Relacja wiele-do-wielu (przepis ↔ składniki)
   - `ingredient_unit_conversions` - Przeliczniki jednostek (np. "1 jajko" = 60g)

2. **`public` schema** - Dane użytkowników, chronione RLS
   - `profiles` - Profile użytkowników z celami żywieniowymi
   - `planned_meals` - Zaplanowane posiłki dla użytkowników
   - `feedback` - Zgłoszenia użytkowników

### Typy ENUM

```sql
-- Typy niestandardowe dla spójności danych
CREATE TYPE gender_enum AS ENUM ('male', 'female');
CREATE TYPE activity_level_enum AS ENUM ('very_low', 'low', 'moderate', 'high', 'very_high');
CREATE TYPE goal_enum AS ENUM ('weight_loss', 'weight_maintenance');
CREATE TYPE meal_type_enum AS ENUM ('breakfast', 'lunch', 'dinner');

-- ✅ NOWY: Kategorie składników (type-safe)
CREATE TYPE ingredient_category_enum AS ENUM (
  'vegetables',      -- warzywa
  'fruits',          -- owoce
  'meat',            -- mięso
  'fish',            -- ryby i owoce morza
  'dairy',           -- nabiał
  'eggs',            -- jaja
  'nuts_seeds',      -- orzechy i nasiona
  'oils_fats',       -- oleje i tłuszcze
  'spices_herbs',    -- przyprawy i zioła
  'flours',          -- mąki (niskowęglowodanowe)
  'beverages',       -- napoje
  'sweeteners',      -- słodziki
  'condiments',      -- sosy i dodatki
  'other'            -- inne
);
```

---

## Konwencje Migracji

### Nazewnictwo Plików

```
supabase/migrations/YYYYMMDDHHmmss_krotki_opis.sql
```

**Przykłady:**

- `20251009120000_create_lowcarbplaner_schema.sql` (aktualna migracja)
- `20251010100000_add_recipe_tags.sql`
- `20251011150000_add_meal_ratings.sql`

### Tworzenie Nowej Migracji

```bash
# Utwórz nowy plik migracji
npx supabase migration new nazwa_migracji

# Zastosuj migracje lokalnie
npx supabase db push

# Reset bazy (OSTROŻNIE! Usuwa dane)
npx supabase db reset

# Załaduj dane testowe
psql postgresql://postgres:postgres@localhost:54322/postgres -f supabase/seed_ingredients.sql
psql postgresql://postgres:postgres@localhost:54322/postgres -f supabase/seed_recipes.sql

npx supabase gen types typescript --project-id "$(cat supabase/.temp/project-ref | tr -d '\n')" --schema public --schema content > src/types/database.types.ts
```

---

## Struktura Migracji

### Kompletny Przykład: Tabela Ingredients

```sql
-- ============================================
-- Tabela: content.ingredients
-- Opis: Słownik składników z wartościami odżywczymi
-- ============================================

create table content.ingredients (
  id bigint generated by default as identity primary key,
  name text not null unique,
  category ingredient_category_enum not null, -- ✅ Type-safe ENUM
  image_url text,
  unit text not null default 'g',
  calories_per_100_units numeric(8, 2) not null check (calories_per_100_units >= 0),
  carbs_per_100_units numeric(8, 2) not null check (carbs_per_100_units >= 0),
  protein_per_100_units numeric(8, 2) not null check (protein_per_100_units >= 0),
  fats_per_100_units numeric(8, 2) not null check (fats_per_100_units >= 0),
  is_divisible boolean not null default true,
  created_at timestamptz not null default now()
);

comment on table content.ingredients is 'Master data for ingredients with nutritional values per 100 units.';
comment on column content.ingredients.category is 'Type-safe category (ENUM): vegetables, fruits, meat, fish, dairy, eggs, nuts_seeds, oils_fats, spices_herbs, flours, beverages, sweeteners, condiments, other.';
comment on column content.ingredients.is_divisible is 'Indicates if ingredient is divisible (e.g., flour) vs. indivisible (e.g., egg).';

-- RLS: read-only dla authenticated users
alter table content.ingredients enable row level security;

create policy "ingredients_select_authenticated"
  on content.ingredients for select
  to authenticated using (true);
```

### Kompletny Przykład: Tabela Recipes z Denormalizacją

```sql
-- ============================================
-- Tabela: content.recipes
-- Opis: Przepisy z denormalizowanymi wartościami odżywczymi (US-013)
-- ============================================

create table content.recipes (
  id bigint generated by default as identity primary key,
  name text not null unique,
  image_url text,
  instructions jsonb not null, -- [{"step": 1, "description": "...", "imageUrl": "..."}]
  meal_types meal_type_enum[] not null,
  tags text[],

  -- ✅ Denormalizowane wartości odżywcze (automatycznie obliczane przez trigger)
  total_calories integer check (total_calories >= 0),
  total_protein_g numeric(8, 2) check (total_protein_g >= 0),
  total_carbs_g numeric(8, 2) check (total_carbs_g >= 0),
  total_fats_g numeric(8, 2) check (total_fats_g >= 0),

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

comment on table content.recipes is 'Master data for recipes with denormalized nutritional totals.';
comment on column content.recipes.total_calories is 'Denormalized total calories, updated automatically by trigger (US-013).';

-- Indeksy GIN dla wydajności
create index idx_recipes_tags_gin on content.recipes using gin (tags);
create index idx_recipes_meal_types_gin on content.recipes using gin (meal_types);

-- Trigger dla updated_at
create trigger recipes_updated_at
  before update on content.recipes
  for each row
  execute function update_updated_at_column();

-- RLS: read-only dla authenticated users
alter table content.recipes enable row level security;

create policy "recipes_select_authenticated"
  on content.recipes for select
  to authenticated using (true);
```

---

## Relacje i Foreign Keys

### 1. Many-to-Many (Recipes ↔ Ingredients)

```sql
-- Tabela łącząca przepisy ze składnikami
create table content.recipe_ingredients (
  recipe_id bigint not null references content.recipes on delete cascade,
  ingredient_id bigint not null references content.ingredients on delete cascade,
  base_amount numeric(8, 2) not null check (base_amount > 0),
  unit text not null default 'g',
  is_scalable boolean not null default false, -- Czy algorytm może skalować
  step_number smallint,

  -- ✅ Denormalizowane makro dla base_amount (automatycznie obliczane)
  calories numeric(8, 2) check (calories >= 0),
  protein_g numeric(8, 2) check (protein_g >= 0),
  carbs_g numeric(8, 2) check (carbs_g >= 0),
  fats_g numeric(8, 2) check (fats_g >= 0),

  primary key (recipe_id, ingredient_id)
);

-- Trigger automatycznie oblicza makro dla base_amount
create trigger recipe_ingredients_nutrition_trigger
  before insert or update on content.recipe_ingredients
  for each row
  execute function calculate_recipe_ingredient_nutrition();

-- RLS: read-only dla authenticated users
alter table content.recipe_ingredients enable row level security;

create policy "recipe_ingredients_select_authenticated"
  on content.recipe_ingredients for select
  to authenticated using (true);
```

### 2. One-to-Many (User → Planned Meals)

```sql
-- Tabela planned_meals dla użytkowników
create table public.planned_meals (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.profiles on delete cascade,
  recipe_id bigint references content.recipes on delete set null,
  meal_date date not null,
  meal_type meal_type_enum not null,
  is_eaten boolean not null default false,
  ingredient_overrides jsonb, -- Modyfikacje gramatury przez użytkownika
  created_at timestamptz not null default now(),

  constraint planned_meals_user_day_type_unique unique (user_id, meal_date, meal_type)
);

-- Indeks dla wydajności
create index idx_planned_meals_user_date on public.planned_meals (user_id, meal_date);

-- RLS: użytkownicy widzą tylko swoje posiłki
alter table public.planned_meals enable row level security;

create policy "planned_meals_select_own"
  on public.planned_meals for select
  to authenticated using (auth.uid() = user_id);

create policy "planned_meals_update_own"
  on public.planned_meals for update
  to authenticated using (auth.uid() = user_id)
  with check (auth.uid() = user_id);
```

### 3. Zapytania z Relacjami

```typescript
// Pobierz zaplanowane posiłki na dziś z pełnymi przepisami i składnikami
const { data } = await supabase
  .from('planned_meals')
  .select(
    `
    *,
    recipe:recipes (
      id,
      name,
      image_url,
      total_calories,
      total_protein_g,
      total_carbs_g,
      total_fats_g,
      instructions,
      recipe_ingredients (
        base_amount,
        unit,
        is_scalable,
        calories,
        protein_g,
        carbs_g,
        fats_g,
        ingredient:ingredients (
          id,
          name,
          category,
          is_divisible
        )
      )
    )
  `
  )
  .eq('user_id', user.id)
  .eq('meal_date', today)
  .order('meal_type')

// Pobierz składniki dla konkretnego przepisu
const { data: recipe } = await supabase
  .from('recipes')
  .select(
    `
    *,
    recipe_ingredients (
      *,
      ingredient:ingredients (*)
    )
  `
  )
  .eq('id', recipeId)
  .single()
```

---

## Typy TypeScript z Supabase

### Generowanie Typów

```bash
# Generuj typy z bazy danych (włącznie z ENUM!)
npx supabase gen types typescript --local > types/database.types.ts
```

### Użycie Typów z ENUM

```typescript
// types/database.types.ts (auto-generated)
export type Database = {
  public: {
    Enums: {
      gender_enum: 'male' | 'female'
      activity_level_enum:
        | 'very_low'
        | 'low'
        | 'moderate'
        | 'high'
        | 'very_high'
      goal_enum: 'weight_loss' | 'weight_maintenance'
      meal_type_enum: 'breakfast' | 'lunch' | 'dinner'
      ingredient_category_enum:
        | 'vegetables'
        | 'fruits'
        | 'meat'
        | 'fish'
        | 'dairy'
        | 'eggs'
        | 'nuts_seeds'
        | 'oils_fats'
        | 'spices_herbs'
        | 'flours'
        | 'beverages'
        | 'sweeteners'
        | 'condiments'
        | 'other'
    }
    Tables: {
      profiles: {
        Row: {
          id: string
          email: string
          gender: Database['public']['Enums']['gender_enum']
          age: number
          target_calories: number
          // ...
        }
        // ...
      }
      planned_meals: {
        Row: {
          id: number
          user_id: string
          recipe_id: number | null
          meal_date: string
          meal_type: Database['public']['Enums']['meal_type_enum']
          is_eaten: boolean
          // ...
        }
        // ...
      }
    }
  }
  content: {
    Tables: {
      ingredients: {
        Row: {
          id: number
          name: string
          category: Database['public']['Enums']['ingredient_category_enum']
          calories_per_100_units: number
          protein_per_100_units: number
          carbs_per_100_units: number
          fats_per_100_units: number
          // ...
        }
        // ...
      }
      recipes: {
        Row: {
          id: number
          name: string
          meal_types: Database['public']['Enums']['meal_type_enum'][]
          total_calories: number | null
          total_protein_g: number | null
          total_carbs_g: number | null
          total_fats_g: number | null
          // ...
        }
        // ...
      }
    }
  }
}

// lib/supabase/client.ts
import type { Database } from '@/types/database.types'

export const supabase = createBrowserClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)

// ✅ Type-safe queries z ENUM!
const { data } = await supabase
  .from('ingredients')
  .select('*')
  .eq('category', 'vegetables') // ✅ Autocomplete dla ENUM!

// ✅ Type-safe insert z ENUM
const { error } = await supabase.from('planned_meals').insert({
  user_id: user.id,
  recipe_id: 123,
  meal_date: '2025-10-09',
  meal_type: 'breakfast', // ✅ Type-checked!
  is_eaten: false,
})
```

### Helper Types dla ENUM

```typescript
// types/enums.ts
import type { Database } from './database.types'

export type IngredientCategory = Database['public']['Enums']['ingredient_category_enum']
export type MealType = Database['public']['Enums']['meal_type_enum']
export type Gender = Database['public']['Enums']['gender_enum']
export type ActivityLevel = Database['public']['Enums']['activity_level_enum']
export type Goal = Database['public']['Enums']['goal_enum']

// Użycie w komponentach
export function IngredientCategoryBadge({ category }: { category: IngredientCategory }) {
  const labels: Record<IngredientCategory, string> = {
    vegetables: 'Warzywa',
    fruits: 'Owoce',
    meat: 'Mięso',
    fish: 'Ryby',
    dairy: 'Nabiał',
    eggs: 'Jaja',
    nuts_seeds: 'Orzechy',
    oils_fats: 'Tłuszcze',
    spices_herbs: 'Przyprawy',
    flours: 'Mąki',
    beverages: 'Napoje',
    sweeteners: 'Słodziki',
    condiments: 'Dodatki',
    other: 'Inne'
  }

  return <Badge>{labels[category]}</Badge>
}
```

---

## Real-time Subscriptions

### 1. Włączenie Realtime dla Tabeli

```sql
-- Włącz realtime dla tabeli
alter publication supabase_realtime add table public.daily_progress;
```

### 2. Subskrypcja Zmian

```typescript
'use client';

import { useEffect } from 'react';
import { supabase } from '@/lib/supabase/client';
import { useQueryClient } from '@tanstack/react-query';

export function useProgressRealtime(userId: string, date: string) {
  const queryClient = useQueryClient();

  useEffect(() => {
    const channel = supabase
      .channel('progress-changes')
      .on(
        'postgres_changes',
        {
          event: '*', // 'INSERT' | 'UPDATE' | 'DELETE'
          schema: 'public',
          table: 'daily_progress',
          filter: `user_id=eq.${userId}`,
        },
        (payload) => {
          console.log('Progress changed:', payload);

          // Invalidate queries
          queryClient.invalidateQueries({ queryKey: ['progress', date] });
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [queryClient, userId, date]);
}

// Użycie w komponencie
export function DailyView() {
  const { user } = useAuth();
  const today = new Date().toISOString().split('T')[0];

  useProgressRealtime(user.id, today); // Auto-refresh on changes
  const { data: progress } = useProgressQuery(today);

  return <div>{/* ... */}</div>;
}
```

---

## Storage (Pliki)

### 1. Tworzenie Bucketa dla Zdjęć Posiłków

```sql
-- Utwórz bucket dla zdjęć przepisów
insert into storage.buckets (id, name, public)
values ('recipe-images', 'recipe-images', true);

-- Polityki dla storage
create policy "Anyone can view recipe images"
  on storage.objects for select
  using (bucket_id = 'recipe-images');

create policy "Authenticated users can upload recipe images"
  on storage.objects for insert
  with check (
    bucket_id = 'recipe-images'
    and auth.role() = 'authenticated'
  );

create policy "Users can update their own recipe images"
  on storage.objects for update
  using (
    bucket_id = 'recipe-images'
    and auth.uid()::text = (storage.foldername(name))[1]
  );
```

### 2. Upload Pliku

```typescript
// lib/utils/storage.ts
export async function uploadRecipeImage(file: File, recipeId: string) {
  const fileExt = file.name.split('.').pop()
  const fileName = `recipes/${recipeId}.${fileExt}`

  const { error } = await supabase.storage
    .from('recipe-images')
    .upload(fileName, file, {
      cacheControl: '3600',
      upsert: true,
    })

  if (error) throw error

  const {
    data: { publicUrl },
  } = supabase.storage.from('recipe-images').getPublicUrl(fileName)

  return publicUrl
}
```

---

## Query Optimization

### 1. Indeksy

```sql
-- Dodaj indeksy dla często używanych kolumn
create index recipes_meal_type_idx on public.recipes(meal_type);
create index recipes_calories_idx on public.recipes(calories);

-- Composite index
create index recipes_meal_type_calories_idx
  on public.recipes(meal_type, calories);

-- Partial index (tylko low-carb recipes)
create index recipes_low_carb_idx
  on public.recipes(carbs)
  where carbs <= 15;

-- Index dla meal plans
create index meal_plans_user_date_idx
  on public.meal_plans(user_id, start_date);

-- Index dla daily progress
create index daily_progress_user_date_idx
  on public.daily_progress(user_id, date);
```

### 2. Optymalizacja Zapytań

```typescript
// ✅ Wybierz tylko potrzebne kolumny
const { data } = await supabase
  .from('recipes')
  .select('id, name, calories, protein, carbs, fats') // Nie używaj '*'
  .eq('meal_type', 'breakfast')
  .limit(10)

// ✅ Paginacja
const { data } = await supabase
  .from('recipes')
  .select('*')
  .range(0, 9) // 0-9 = pierwsze 10
  .order('calories', { ascending: true })

// ❌ Unikaj N+1 queries
// Zamiast:
for (const meal of meals) {
  const { data: recipe } = await supabase
    .from('recipes')
    .select('*')
    .eq('id', meal.recipe_id)
}

// ✅ Użyj relacji:
const { data } = await supabase.from('meals').select('*, recipe:recipes(*)')
```

---

## Database Functions

### 1. Custom Function (Generuj Plan Posiłków)

```sql
create or replace function generate_meal_plan(
  p_user_id uuid,
  p_target_calories numeric,
  p_start_date date
)
returns json as $$
declare
  v_meal_plan_id uuid;
  v_day int;
  v_meal_type text;
  v_target_calories_per_meal numeric;
  v_recipe record;
begin
  -- Utwórz nowy plan posiłków
  insert into meal_plans (user_id, start_date, target_calories)
  values (p_user_id, p_start_date, p_target_calories)
  returning id into v_meal_plan_id;

  -- Kalorie na posiłek (dzielimy na 3 posiłki)
  v_target_calories_per_meal := p_target_calories / 3;

  -- Dla każdego dnia (1-7)
  for v_day in 1..7 loop
    -- Dla każdego typu posiłku
    foreach v_meal_type in array array['breakfast', 'lunch', 'dinner'] loop
      -- Znajdź losowy przepis w odpowiednim zakresie kalorii (±15%)
      select * into v_recipe
      from recipes
      where meal_type = v_meal_type
        and calories between (v_target_calories_per_meal * 0.85)
        and (v_target_calories_per_meal * 1.15)
        and is_public = true
      order by random()
      limit 1;

      -- Dodaj posiłek do planu
      if v_recipe.id is not null then
        insert into meals (meal_plan_id, recipe_id, day_number, meal_type)
        values (v_meal_plan_id, v_recipe.id, v_day, v_meal_type);
      end if;
    end loop;
  end loop;

  return json_build_object(
    'success', true,
    'meal_plan_id', v_meal_plan_id
  );
end;
$$ language plpgsql security definer;
```

```typescript
// Wywołanie z TypeScript
const { data, error } = await supabase.rpc('generate_meal_plan', {
  p_user_id: user.id,
  p_target_calories: 2000,
  p_start_date: new Date().toISOString().split('T')[0],
})
```

---

## Seed Data (Opcjonalnie)

```sql
-- supabase/seed.sql
-- Dane testowe dla development

-- Wstaw użytkownika testowego
insert into auth.users (id, email)
values
  ('11111111-1111-1111-1111-111111111111', 'test@example.com')
on conflict (id) do nothing;

-- Wstaw profil użytkownika
insert into public.user_profiles (user_id, gender, age, weight, height, target_calories)
values
  ('11111111-1111-1111-1111-111111111111', 'male', 30, 80, 180, 2000)
on conflict (user_id) do nothing;

-- Wstaw przykładowe przepisy
insert into public.recipes (name, description, calories, protein, carbs, fats, meal_type, is_public)
values
  ('Jajecznica z awokado', 'Pyszne śniadanie low-carb', 350, 18, 8, 28, 'breakfast', true),
  ('Grillowany kurczak z warzywami', 'Zdrowy obiad', 450, 45, 15, 22, 'lunch', true),
  ('Stek z sałatką', 'Kolacja bogata w białko', 500, 50, 10, 30, 'dinner', true)
on conflict do nothing;
```

```bash
# Załaduj seed data
npx supabase db reset
```

---

📚 **Więcej szczegółów:** Zobacz inne pliki w `.claude/docs/`
