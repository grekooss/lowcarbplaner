````markdown
# Schemat Bazy Danych PostgreSQL dla Aplikacji "LowCarbPlaner"

## 1. Lista tabel z ich kolumnami, typami danych i ograniczeniami

### Typy niestandardowe (ENUM)

```sql
CREATE TYPE gender_enum AS ENUM ('male', 'female');
CREATE TYPE activity_level_enum AS ENUM ('very_low', 'low', 'moderate', 'high', 'very_high');
CREATE TYPE goal_enum AS ENUM ('weight_loss', 'weight_maintenance');
CREATE TYPE meal_type_enum AS ENUM ('breakfast', 'lunch', 'dinner');
CREATE TYPE ingredient_category_enum AS ENUM (
  'vegetables',      -- warzywa
  'fruits',          -- owoce
  'meat',            -- mięso
  'fish',            -- ryby i owoce morza
  'dairy',           -- nabiał
  'eggs',            -- jaja
  'nuts_seeds',      -- orzechy i nasiona
  'oils_fats',       -- oleje i tłuszcze
  'spices_herbs',    -- przyprawy i zioła
  'flours',          -- mąki (niskowęglowodanowe: migdałowa, kokosowa)
  'beverages',       -- napoje
  'sweeteners',      -- słodziki
  'condiments',      -- sosy i dodatki
  'other'            -- inne
);
```
````

### Schemat: `public` (Dane specyficzne dla użytkownika)

#### Tabela `profiles`

Przechowuje dane profilowe i cele żywieniowe użytkownika. Tabela jest powiązana 1-do-1 z tabelą `auth.users` z Supabase.

```sql
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
  email TEXT UNIQUE NOT NULL,
  gender gender_enum NOT NULL,
  age SMALLINT NOT NULL CHECK (age > 0 AND age < 120),
  weight_kg NUMERIC(5, 2) NOT NULL CHECK (weight_kg > 0),
  height_cm SMALLINT NOT NULL CHECK (height_cm > 0),
  activity_level activity_level_enum NOT NULL,
  goal goal_enum NOT NULL,
  weight_loss_rate_kg_week NUMERIC(3, 2) CHECK (weight_loss_rate_kg_week > 0), -- NULL if goal is not 'weight_loss'

  -- Obliczone cele
  target_calories INTEGER NOT NULL CHECK (target_calories > 0),
  target_carbs_g INTEGER NOT NULL CHECK (target_carbs_g >= 0),
  target_protein_g INTEGER NOT NULL CHECK (target_protein_g >= 0),
  target_fats_g INTEGER NOT NULL CHECK (target_fats_g >= 0),

  -- Metadane
  disclaimer_accepted_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON COLUMN public.profiles.id IS 'Klucz obcy do auth.users.id.';
COMMENT ON COLUMN public.profiles.weight_loss_rate_kg_week IS 'Tempo utraty wagi w kg/tydzień, np. 0.5.';
COMMENT ON TABLE public.profiles IS 'Profil użytkownika, jego dane wejściowe i obliczone cele żywieniowe.';
```

#### Tabela `planned_meals`

Główna tabela transakcyjna przechowująca wygenerowany plan posiłków dla każdego użytkownika.

```sql
CREATE TABLE public.planned_meals (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles ON DELETE CASCADE,
  recipe_id BIGINT REFERENCES content.recipes ON DELETE SET NULL,
  meal_date DATE NOT NULL,
  meal_type meal_type_enum NOT NULL,
  is_eaten BOOLEAN NOT NULL DEFAULT FALSE,
  ingredient_overrides JSONB, -- Przechowuje modyfikacje gramatury dokonane przez użytkownika, np. {"ingredient_id": 12, "new_amount": 150}
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  CONSTRAINT planned_meals_user_day_type_unique UNIQUE (user_id, meal_date, meal_type)
);

COMMENT ON COLUMN public.planned_meals.ingredient_overrides IS 'Zmiany w gramaturze składników wprowadzone przez użytkownika.';
COMMENT ON TABLE public.planned_meals IS 'Plan posiłków dla użytkowników na każdy dzień.';
```

#### Tabela `feedback`

Przechowuje opinie i zgłoszenia problemów od użytkowników.

```sql
CREATE TABLE public.feedback (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles ON DELETE CASCADE,
  content TEXT NOT NULL,
  metadata JSONB, -- Przechowuje dodatkowe informacje, np. wersja aplikacji, system operacyjny
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON COLUMN public.feedback.metadata IS 'Dodatkowe dane kontekstowe zgłoszenia, np. {"appVersion": "1.0.1", "os": "iOS"}.';
COMMENT ON TABLE public.feedback IS 'Opinie i zgłoszenia od użytkowników.';
```

### Schemat: `content` (Dane główne, zarządzane przez administratorów)

#### Tabela `ingredients`

Słownik wszystkich składników wraz z ich wartościami odżywczymi.

```sql
CREATE TABLE content.ingredients (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  category ingredient_category_enum NOT NULL, -- Kategoria składnika (ENUM dla spójności danych)
  image_url TEXT, -- URL do zdjęcia składnika w Supabase Storage
  unit TEXT NOT NULL DEFAULT 'g', -- Domyślna jednostka dla wartości odżywczych (np. g, ml)
  calories_per_100_units NUMERIC(8, 2) NOT NULL,
  carbs_per_100_units NUMERIC(8, 2) NOT NULL,
  protein_per_100_units NUMERIC(8, 2) NOT NULL,
  fats_per_100_units NUMERIC(8, 2) NOT NULL,
  is_divisible BOOLEAN NOT NULL DEFAULT TRUE, -- Czy składnik może występować w ułamkach (np. mąka, oliwa)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON COLUMN content.ingredients.category IS 'Kategoria składnika (ENUM): vegetables, fruits, meat, fish, dairy, eggs, nuts_seeds, oils_fats, spices_herbs, flours, beverages, sweeteners, condiments, other.';
COMMENT ON COLUMN content.ingredients.image_url IS 'URL do zdjęcia składnika, opcjonalne, przechowywane w Supabase Storage.';
COMMENT ON COLUMN content.ingredients.is_divisible IS 'Określa, czy składnik jest "podzielny" (np. mąka), w przeciwieństwie do "niepodzielnego" (np. jajko).';
COMMENT ON TABLE content.ingredients IS 'Dane "master" dla składników i ich makroskładników na 100 jednostek.';
```

#### Tabela `ingredient_unit_conversions`

Tabela pomocnicza do konwersji niestandardowych jednostek (np. "1 jajko") na gramy.

```sql
CREATE TABLE content.ingredient_unit_conversions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ingredient_id BIGINT NOT NULL REFERENCES content.ingredients ON DELETE CASCADE,
    unit_name TEXT NOT NULL, -- np. 'sztuka', 'plaster', 'łyżka'
    grams_equivalent NUMERIC(8, 2) NOT NULL,

    CONSTRAINT ingredient_unit_conversions_unique UNIQUE (ingredient_id, unit_name)
);

COMMENT ON TABLE content.ingredient_unit_conversions IS 'Definiuje przeliczniki dla niestandardowych jednostek składników na gramy.';
```

#### Tabela `recipes`

Słownik wszystkich przepisów dostępnych w aplikacji.

```sql
CREATE TABLE content.recipes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  image_url TEXT,
  instructions JSONB NOT NULL, -- Lista kroków, np. [{"step": 1, "description": "...", "imageUrl": "..."}, ...]
  meal_types meal_type_enum[] NOT NULL, -- Typy posiłków, do których pasuje przepis
  tags TEXT[], -- Tagi do filtrowania i kategoryzacji, np. ['kurczak', 'szybkie', 'patelnia']

  -- Zdenormalizowane wartości odżywcze dla całego przepisu (US-013)
  total_calories INTEGER, -- Aktualizowane przez trigger
  total_protein_g NUMERIC(8, 2), -- Aktualizowane przez trigger
  total_carbs_g NUMERIC(8, 2), -- Aktualizowane przez trigger
  total_fats_g NUMERIC(8, 2), -- Aktualizowane przez trigger

  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON COLUMN content.recipes.instructions IS 'Instrukcje przygotowania w formacie JSONB.';
COMMENT ON COLUMN content.recipes.total_calories IS 'Zdenormalizowana suma kalorii ze składników bazowych, dla szybszego sortowania i wyświetlania (US-013).';
COMMENT ON COLUMN content.recipes.total_protein_g IS 'Zdenormalizowana suma białka ze składników bazowych (US-013).';
COMMENT ON COLUMN content.recipes.total_carbs_g IS 'Zdenormalizowana suma węglowodanów ze składników bazowych (US-013).';
COMMENT ON COLUMN content.recipes.total_fats_g IS 'Zdenormalizowana suma tłuszczów ze składników bazowych (US-013).';
COMMENT ON TABLE content.recipes IS 'Dane "master" dla przepisów.';
```

#### Tabela `recipe_ingredients`

Tabela łącząca, definiująca relację wiele-do-wielu między przepisami a składnikami.

```sql
CREATE TABLE content.recipe_ingredients (
  recipe_id BIGINT NOT NULL REFERENCES content.recipes ON DELETE CASCADE,
  ingredient_id BIGINT NOT NULL REFERENCES content.ingredients ON DELETE CASCADE,
  base_amount NUMERIC(8, 2) NOT NULL, -- Ilość składnika w jednostce bazowej (g, ml, szt.)
  unit TEXT NOT NULL DEFAULT 'g', -- Jednostka dla base_amount
  is_scalable BOOLEAN NOT NULL DEFAULT FALSE, -- Czy algorytm może skalować ten składnik w przepisie
  step_number SMALLINT, -- Opcjonalny numer kroku, w którym używany jest składnik

  -- Zdenormalizowane makro składnika dla danej ilości (US-013)
  calories NUMERIC(8, 2), -- Kalorie dla base_amount, aktualizowane przez trigger
  protein_g NUMERIC(8, 2), -- Białko dla base_amount, aktualizowane przez trigger
  carbs_g NUMERIC(8, 2), -- Węglowodany dla base_amount, aktualizowane przez trigger
  fats_g NUMERIC(8, 2), -- Tłuszcze dla base_amount, aktualizowane przez trigger

  PRIMARY KEY (recipe_id, ingredient_id)
);

COMMENT ON COLUMN content.recipe_ingredients.is_scalable IS 'Flaga określająca, czy ilość tego składnika może być modyfikowana przez algorytm generujący plan.';
COMMENT ON COLUMN content.recipe_ingredients.calories IS 'Zdenormalizowane kalorie dla base_amount tego składnika, dla wydajności wyświetlania (US-013).';
COMMENT ON COLUMN content.recipe_ingredients.protein_g IS 'Zdenormalizowane białko dla base_amount tego składnika (US-013).';
COMMENT ON COLUMN content.recipe_ingredients.carbs_g IS 'Zdenormalizowane węglowodany dla base_amount tego składnika (US-013).';
COMMENT ON COLUMN content.recipe_ingredients.fats_g IS 'Zdenormalizowane tłuszcze dla base_amount tego składnika (US-013).';
COMMENT ON TABLE content.recipe_ingredients IS 'Tabela łącząca przepisy ze składnikami.';
```

## 2. Relacje między tabelami

- **`auth.users` ↔ `public.profiles` (Jeden-do-jednego)**: Każdy użytkownik w `auth.users` ma dokładnie jeden profil w `public.profiles`. Usunięcie użytkownika kaskadowo usuwa jego profil (`ON DELETE CASCADE`).
- **`public.profiles` → `public.planned_meals` (Jeden-do-wielu)**: Użytkownik może mieć wiele zaplanowanych posiłków.
- **`public.profiles` → `public.feedback` (Jeden-do-wielu)**: Użytkownik może przesłać wiele zgłoszeń.
- **`content.recipes` ↔ `content.ingredients` (Wiele-do-wielu)**: Relacja zrealizowana przez tabelę łączącą `content.recipe_ingredients`. Przepis składa się z wielu składników, a składnik może być częścią wielu przepisów.
- **`content.recipes` → `public.planned_meals` (Jeden-do-wielu)**: Jeden przepis może być częścią wielu zaplanowanych posiłków dla różnych użytkowników. Jeśli przepis zostanie usunięty, pole `recipe_id` w `planned_meals` zostanie ustawione na `NULL` (`ON DELETE SET NULL`), aby zachować historię spożycia bez naruszania integralności.
- **`content.ingredients` → `content.ingredient_unit_conversions` (Jeden-do-wielu)**: Jeden składnik może mieć wiele niestandardowych jednostek przeliczeniowych.

## 3. Indeksy

Indeksy zostaną utworzone w celu optymalizacji najczęstszych zapytań.

```sql
-- Indeks do szybkiego wyszukiwania planu posiłków dla danego użytkownika i zakresu dat.
CREATE INDEX idx_planned_meals_user_date ON public.planned_meals (user_id, meal_date);

-- Indeks GIN do efektywnego wyszukiwania przepisów po tagach.
CREATE INDEX idx_recipes_tags_gin ON content.recipes USING GIN (tags);

-- Indeks GIN do efektywnego wyszukiwania przepisów po typach posiłków.
CREATE INDEX idx_recipes_meal_types_gin ON content.recipes USING GIN (meal_types);

-- Indeksy na kluczach obcych są tworzone automatycznie przez PostgreSQL, ale ich istnienie jest kluczowe.
-- np. na public.planned_meals(user_id), public.planned_meals(recipe_id) etc.
```

## 4. Zasady PostgreSQL (Row Level Security)

RLS zostanie włączone na wszystkich tabelach w schemacie `public`, aby zapewnić, że użytkownicy mają dostęp wyłącznie do swoich danych.

```sql
-- Włączenie RLS dla tabel
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.planned_meals ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.feedback ENABLE ROW LEVEL SECURITY;

-- Polityki dla tabeli `profiles`
CREATE POLICY "Users can view and update their own profile."
  ON public.profiles FOR ALL
  USING (auth.uid() = id);

-- Polityki dla tabeli `planned_meals`
CREATE POLICY "Users can manage their own planned meals."
  ON public.planned_meals FOR ALL
  USING (auth.uid() = user_id);

-- Polityki dla tabeli `feedback`
CREATE POLICY "Users can create and view their own feedback."
  ON public.feedback FOR ALL
  USING (auth.uid() = user_id);

-- Dostęp do danych w schemacie `content`
-- Tabele w schemacie `content` są publicznie dostępne do odczytu dla wszystkich zalogowanych użytkowników.
-- Modyfikacja będzie ograniczona na poziomie uprawnień roli (np. `content_manager`), a nie RLS.
ALTER TABLE content.recipes ENABLE ROW LEVEL SECURITY;
ALTER TABLE content.ingredients ENABLE ROW LEVEL SECURITY;
ALTER TABLE content.recipe_ingredients ENABLE ROW LEVEL SECURITY;
ALTER TABLE content.ingredient_unit_conversions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Content is viewable by authenticated users."
  ON content.recipes FOR SELECT
  USING (auth.role() = 'authenticated');

CREATE POLICY "Content is viewable by authenticated users."
  ON content.ingredients FOR SELECT
  USING (auth.role() = 'authenticated');

CREATE POLICY "Content is viewable by authenticated users."
  ON content.recipe_ingredients FOR SELECT
  USING (auth.role() = 'authenticated');

CREATE POLICY "Content is viewable by authenticated users."
  ON content.ingredient_unit_conversions FOR SELECT
  USING (auth.role() = 'authenticated');
```

## 5. Dodatkowe uwagi i wyjaśnienia

1.  **Struktura Schematów**: Zastosowano dwa schematy: `public` dla danych specyficznych dla użytkownika, chronionych przez RLS, oraz `content` dla danych głównych (master data), które są zarządzane przez administratorów i publicznie dostępne do odczytu dla użytkowników.
2.  **Automatyzacja (Triggery)**:
    - **Tworzenie Profilu**: Zostanie utworzony trigger PostgreSQL, który automatycznie tworzy nowy wiersz w `public.profiles` po zarejestrowaniu nowego użytkownika w `auth.users`.
    - **Aktualizacja `updated_at`**: Trigger będzie automatycznie aktualizował kolumnę `updated_at` w tabelach `profiles` i `recipes` przy każdej modyfikacji wiersza.
    - **Denormalizacja Makro Składników (US-013)**: Trigger na tabeli `content.recipe_ingredients` będzie automatycznie obliczał i zapisywał wartości `calories`, `protein_g`, `carbs_g`, `fats_g` dla każdego składnika na podstawie `base_amount` i wartości z tabeli `ingredients` (np. `calories = base_amount * calories_per_100_units / 100`).
    - **Denormalizacja Makro Przepisu (US-013)**: Trigger na tabeli `content.recipe_ingredients` będzie przeliczał i aktualizował pola `total_calories`, `total_protein_g`, `total_carbs_g`, `total_fats_g` w tabeli `content.recipes` po każdej zmianie składników, agregując wartości ze wszystkich składników przepisu. To znacząco optymalizuje funkcję wymiany posiłku oraz wyświetlanie całościowych wartości odżywczych.
3.  **Skalowalność Składników**: Zastosowano dwie flagi: `ingredients.is_divisible` (ogólna właściwość składnika) oraz `recipe_ingredients.is_scalable` (właściwość składnika w kontekście konkretnego przepisu). To daje algorytmowi precyzyjną kontrolę nad tym, które ilości można modyfikować.
4.  **Lista Zakupów**: Lista zakupów nie jest przechowywana jako osobna tabela. Będzie generowana dynamicznie "w locie" za pomocą widoku (`VIEW`) lub funkcji PostgreSQL, agregując składniki z tabeli `planned_meals` na podstawie oryginalnie wygenerowanego planu. Stan odznaczenia produktów na liście będzie zarządzany po stronie klienta.
5.  **Polityki `ON DELETE`**:
    - `ON DELETE CASCADE` na kluczach obcych wskazujących na `profiles.id` lub `auth.users.id` zapewnia zgodność z RODO, usuwając wszystkie dane użytkownika po usunięciu jego konta.
    - `ON DELETE SET NULL` dla `planned_meals.recipe_id` zapobiega utracie danych historycznych użytkownika w przypadku usunięcia przepisu z bazy. Plan posiłku nadal istnieje, ale bez powiązania z usuniętym przepisem.
6.  **Retencja Danych**: Zgodnie z notatkami, zostanie wdrożony mechanizm (np. za pomocą `pg_cron`) do okresowego usuwania starych, niepotrzebnych już rekordów z tabeli `planned_meals` (np. starszych niż 30 dni), aby utrzymać wydajność bazy danych.

```

```
