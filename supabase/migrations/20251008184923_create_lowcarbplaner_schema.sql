-- =====================================================================
-- Migration: Create LowCarbPlaner Database Schema
-- Description: Comprehensive schema creation for LowCarbPlaner MVP
-- Created: 2025-10-08 18:49:23 UTC
--
-- Tables Created:
--   Schema 'content': ingredients, ingredient_unit_conversions, recipes, recipe_ingredients
--   Schema 'public': profiles, planned_meals, feedback
--
-- Features:
--   - Row Level Security (RLS) enabled on all tables
--   - Granular RLS policies for authenticated and anon roles
--   - Automatic triggers for updated_at columns
--   - Automatic profile creation on user signup
--   - Denormalized total_calories calculation for recipes
--   - Comprehensive indexes for performance optimization
-- =====================================================================

-- =====================================================================
-- SECTION 1: CREATE CUSTOM TYPES (ENUMS)
-- =====================================================================

-- gender enum for user profile
create type public.gender_enum as enum ('male', 'female');

-- activity level enum for calculating TDEE (Total Daily Energy Expenditure)
create type public.activity_level_enum as enum (
  'very_low',    -- sedentary lifestyle
  'low',         -- light exercise 1-3 days/week
  'moderate',    -- moderate exercise 3-5 days/week
  'high',        -- active exercise 6-7 days/week
  'very_high'    -- very active + physical job or 2x training per day
);

-- goal enum for diet plan (MVP supports weight loss and maintenance only)
create type public.goal_enum as enum (
  'weight_loss',
  'weight_maintenance'
);

-- meal type enum for categorizing recipes and daily plan
create type public.meal_type_enum as enum (
  'breakfast',
  'lunch',
  'dinner'
);

-- =====================================================================
-- SECTION 2: CREATE SCHEMA 'content' (Master Data)
-- =====================================================================
-- This schema contains all master data managed by administrators
-- and is publicly readable by authenticated users.
-- =====================================================================

-- create content schema if not exists
create schema if not exists content;

-- ---------------------------------------------------------------------
-- Table: content.ingredients
-- Purpose: Master data for all ingredients with nutritional values
-- ---------------------------------------------------------------------
create table content.ingredients (
  id bigint generated by default as identity primary key,
  name text not null unique,

  -- unit defines the base unit for nutritional values (e.g., 'g' for grams, 'ml' for milliliters)
  unit text not null default 'g',

  -- nutritional values per 100 units (e.g., per 100g)
  calories_per_100_units numeric(8, 2) not null check (calories_per_100_units >= 0),
  carbs_per_100_units numeric(8, 2) not null check (carbs_per_100_units >= 0),
  protein_per_100_units numeric(8, 2) not null check (protein_per_100_units >= 0),
  fats_per_100_units numeric(8, 2) not null check (fats_per_100_units >= 0),

  -- is_divisible determines if ingredient can be used in fractions (e.g., flour=true, egg=false)
  -- this affects UI representation and amount input validation
  is_divisible boolean not null default true,

  created_at timestamptz not null default now()
);

comment on table content.ingredients is 'Master data for ingredients with nutritional information per 100 units';
comment on column content.ingredients.unit is 'Base unit for nutritional values (g, ml, etc.)';
comment on column content.ingredients.is_divisible is 'Determines if ingredient can be divided (flour=true, egg=false)';
comment on column content.ingredients.calories_per_100_units is 'Calories per 100 units of base unit';
comment on column content.ingredients.carbs_per_100_units is 'Carbohydrates in grams per 100 units';
comment on column content.ingredients.protein_per_100_units is 'Protein in grams per 100 units';
comment on column content.ingredients.fats_per_100_units is 'Fats in grams per 100 units';

-- ---------------------------------------------------------------------
-- Table: content.ingredient_unit_conversions
-- Purpose: Custom unit conversions (e.g., "1 piece" = 50g)
-- ---------------------------------------------------------------------
create table content.ingredient_unit_conversions (
  id bigint generated by default as identity primary key,
  ingredient_id bigint not null references content.ingredients on delete cascade,

  -- unit_name defines custom unit (e.g., 'piece', 'slice', 'tablespoon')
  unit_name text not null,

  -- grams_equivalent defines how many grams this custom unit equals
  grams_equivalent numeric(8, 2) not null check (grams_equivalent > 0),

  -- ensure unique combinations of ingredient and custom unit
  constraint ingredient_unit_conversions_unique unique (ingredient_id, unit_name)
);

comment on table content.ingredient_unit_conversions is 'Conversion rates from custom units to grams for ingredients';
comment on column content.ingredient_unit_conversions.unit_name is 'Custom unit name (e.g., piece, slice, tablespoon)';
comment on column content.ingredient_unit_conversions.grams_equivalent is 'Equivalent weight in grams for this custom unit';

-- ---------------------------------------------------------------------
-- Table: content.recipes
-- Purpose: Master data for all recipes available in the app
-- ---------------------------------------------------------------------
create table content.recipes (
  id bigint generated by default as identity primary key,
  name text not null unique,
  image_url text,

  -- instructions stored as JSONB array with step-by-step details
  -- format: [{"step": 1, "description": "...", "imageUrl": "..."}, ...]
  instructions jsonb not null,

  -- meal_types defines which meal types this recipe is suitable for
  -- array allows recipes to be used for multiple meal types (e.g., breakfast AND lunch)
  meal_types public.meal_type_enum[] not null,

  -- tags for categorization and filtering (e.g., ['chicken', 'quick', 'pan'])
  tags text[],

  -- denormalized total_calories for performance optimization in meal replacement algorithm
  -- this value is automatically calculated and updated by trigger
  total_calories integer,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

comment on table content.recipes is 'Master data for recipes with instructions and metadata';
comment on column content.recipes.instructions is 'Step-by-step cooking instructions in JSONB format';
comment on column content.recipes.meal_types is 'Array of meal types this recipe is suitable for';
comment on column content.recipes.tags is 'Tags for filtering and categorization';
comment on column content.recipes.total_calories is 'Denormalized total calories (auto-calculated by trigger)';

-- ---------------------------------------------------------------------
-- Table: content.recipe_ingredients
-- Purpose: Junction table for many-to-many relationship between recipes and ingredients
-- ---------------------------------------------------------------------
create table content.recipe_ingredients (
  recipe_id bigint not null references content.recipes on delete cascade,
  ingredient_id bigint not null references content.ingredients on delete cascade,

  -- base_amount defines the quantity of ingredient in the recipe
  base_amount numeric(8, 2) not null check (base_amount > 0),

  -- unit defines the unit for base_amount (e.g., 'g', 'ml', 'piece')
  unit text not null default 'g',

  -- is_scalable determines if the meal generation algorithm can modify this ingredient's amount
  -- e.g., main protein source might be scalable, but salt might not be
  is_scalable boolean not null default false,

  -- step_number optionally links ingredient to specific step in instructions
  step_number smallint,

  primary key (recipe_id, ingredient_id)
);

comment on table content.recipe_ingredients is 'Junction table linking recipes to ingredients with amounts';
comment on column content.recipe_ingredients.base_amount is 'Quantity of ingredient in base recipe';
comment on column content.recipe_ingredients.unit is 'Unit for base_amount (g, ml, piece, etc.)';
comment on column content.recipe_ingredients.is_scalable is 'Whether algorithm can modify this ingredient amount';
comment on column content.recipe_ingredients.step_number is 'Optional step number where ingredient is used';

-- =====================================================================
-- SECTION 3: CREATE TABLES IN SCHEMA 'public' (User Data)
-- =====================================================================
-- This schema contains user-specific data protected by RLS
-- =====================================================================

-- ---------------------------------------------------------------------
-- Table: public.profiles
-- Purpose: User profile with nutritional goals (1:1 with auth.users)
-- ---------------------------------------------------------------------
create table public.profiles (
  -- id references auth.users.id for 1:1 relationship
  -- cascade delete ensures GDPR compliance when user account is deleted
  id uuid primary key references auth.users on delete cascade,

  email text unique not null,
  gender public.gender_enum not null,

  -- age constraints ensure realistic values
  age smallint not null check (age > 0 and age < 120),

  -- weight in kilograms with 2 decimal precision
  weight_kg numeric(5, 2) not null check (weight_kg > 0),

  -- height in centimeters
  height_cm smallint not null check (height_cm > 0),

  activity_level public.activity_level_enum not null,
  goal public.goal_enum not null,

  -- weight_loss_rate only applicable when goal is 'weight_loss'
  -- null for 'weight_maintenance' goal
  weight_loss_rate_kg_week numeric(3, 2) check (weight_loss_rate_kg_week > 0),

  -- calculated nutritional targets based on BMR/TDEE formulas
  -- these values are calculated by application logic and stored here
  target_calories integer not null check (target_calories > 0),
  target_carbs_g integer not null check (target_carbs_g >= 0),
  target_protein_g integer not null check (target_protein_g >= 0),
  target_fats_g integer not null check (target_fats_g >= 0),

  -- metadata for compliance and tracking
  disclaimer_accepted_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

comment on table public.profiles is 'User profiles with input data and calculated nutritional targets';
comment on column public.profiles.id is 'Foreign key to auth.users.id (1:1 relationship)';
comment on column public.profiles.weight_loss_rate_kg_week is 'Weight loss rate in kg/week (e.g., 0.5)';
comment on column public.profiles.target_calories is 'Daily calorie target calculated from BMR/TDEE';
comment on column public.profiles.target_carbs_g is 'Daily carbohydrate target in grams';
comment on column public.profiles.target_protein_g is 'Daily protein target in grams';
comment on column public.profiles.target_fats_g is 'Daily fat target in grams';
comment on column public.profiles.disclaimer_accepted_at is 'Timestamp when user accepted health disclaimer';

-- ---------------------------------------------------------------------
-- Table: public.planned_meals
-- Purpose: Main transactional table storing generated meal plan for each user
-- ---------------------------------------------------------------------
create table public.planned_meals (
  id bigint generated by default as identity primary key,

  -- user_id links to profiles with cascade delete for GDPR compliance
  user_id uuid not null references public.profiles on delete cascade,

  -- recipe_id uses SET NULL on delete to preserve user's meal history
  -- even if recipe is removed from content database
  recipe_id bigint references content.recipes on delete set null,

  meal_date date not null,
  meal_type public.meal_type_enum not null,

  -- is_eaten tracks whether user marked meal as consumed
  is_eaten boolean not null default false,

  -- ingredient_overrides stores user modifications to ingredient amounts
  -- format: [{"ingredient_id": 12, "new_amount": 150}, ...]
  ingredient_overrides jsonb,

  created_at timestamptz not null default now(),

  -- ensure only one meal per user per day per meal type
  constraint planned_meals_user_day_type_unique unique (user_id, meal_date, meal_type)
);

comment on table public.planned_meals is 'User meal plans for each day';
comment on column public.planned_meals.recipe_id is 'Recipe reference (SET NULL on delete to preserve history)';
comment on column public.planned_meals.is_eaten is 'Whether user marked this meal as consumed';
comment on column public.planned_meals.ingredient_overrides is 'User modifications to ingredient amounts in JSONB format';

-- ---------------------------------------------------------------------
-- Table: public.feedback
-- Purpose: User feedback and issue reports
-- ---------------------------------------------------------------------
create table public.feedback (
  id bigint generated by default as identity primary key,

  -- user_id links to profiles with cascade delete
  user_id uuid not null references public.profiles on delete cascade,

  content text not null,

  -- metadata stores additional context about the feedback submission
  -- format: {"appVersion": "1.0.1", "os": "iOS", "userAgent": "..."}
  metadata jsonb,

  created_at timestamptz not null default now()
);

comment on table public.feedback is 'User feedback and issue reports';
comment on column public.feedback.metadata is 'Additional context data (app version, OS, etc.)';

-- =====================================================================
-- SECTION 4: CREATE INDEXES FOR PERFORMANCE OPTIMIZATION
-- =====================================================================

-- index for fast lookup of user's meal plan by date range
-- this is the most common query pattern in the app
create index idx_planned_meals_user_date on public.planned_meals (user_id, meal_date);

-- index for filtering planned meals by eaten status
-- useful for progress tracking queries
create index idx_planned_meals_is_eaten on public.planned_meals (user_id, is_eaten);

-- gin index for efficient recipe search by tags
-- enables fast queries like: WHERE 'chicken' = ANY(tags)
create index idx_recipes_tags_gin on content.recipes using gin (tags);

-- gin index for efficient recipe filtering by meal types
-- enables fast queries like: WHERE 'breakfast' = ANY(meal_types)
create index idx_recipes_meal_types_gin on content.recipes using gin (meal_types);

-- index for recipe_ingredients to optimize joins
create index idx_recipe_ingredients_recipe_id on content.recipe_ingredients (recipe_id);
create index idx_recipe_ingredients_ingredient_id on content.recipe_ingredients (ingredient_id);

-- index for feedback queries (e.g., admin dashboard)
create index idx_feedback_user_id on public.feedback (user_id);
create index idx_feedback_created_at on public.feedback (created_at desc);

-- =====================================================================
-- SECTION 5: ENABLE ROW LEVEL SECURITY (RLS)
-- =====================================================================
-- RLS is enabled on ALL tables to ensure data security
-- =====================================================================

-- enable rls on content schema tables (master data)
alter table content.ingredients enable row level security;
alter table content.ingredient_unit_conversions enable row level security;
alter table content.recipes enable row level security;
alter table content.recipe_ingredients enable row level security;

-- enable rls on public schema tables (user data)
alter table public.profiles enable row level security;
alter table public.planned_meals enable row level security;
alter table public.feedback enable row level security;

-- =====================================================================
-- SECTION 6: CREATE RLS POLICIES FOR SCHEMA 'content'
-- =====================================================================
-- Content tables are publicly readable by authenticated users
-- Only admin roles can modify (handled via database roles, not RLS)
-- =====================================================================

-- ---------------------------------------------------------------------
-- Policies for content.ingredients
-- ---------------------------------------------------------------------

-- policy: authenticated users can read all ingredients
create policy "authenticated_users_can_select_ingredients"
  on content.ingredients
  for select
  to authenticated
  using (true);

-- policy: anonymous users can read all ingredients (for public recipe browsing if needed)
create policy "anon_users_can_select_ingredients"
  on content.ingredients
  for select
  to anon
  using (true);

-- ---------------------------------------------------------------------
-- Policies for content.ingredient_unit_conversions
-- ---------------------------------------------------------------------

-- policy: authenticated users can read all unit conversions
create policy "authenticated_users_can_select_unit_conversions"
  on content.ingredient_unit_conversions
  for select
  to authenticated
  using (true);

-- policy: anonymous users can read all unit conversions
create policy "anon_users_can_select_unit_conversions"
  on content.ingredient_unit_conversions
  for select
  to anon
  using (true);

-- ---------------------------------------------------------------------
-- Policies for content.recipes
-- ---------------------------------------------------------------------

-- policy: authenticated users can read all recipes
create policy "authenticated_users_can_select_recipes"
  on content.recipes
  for select
  to authenticated
  using (true);

-- policy: anonymous users can read all recipes
create policy "anon_users_can_select_recipes"
  on content.recipes
  for select
  to anon
  using (true);

-- ---------------------------------------------------------------------
-- Policies for content.recipe_ingredients
-- ---------------------------------------------------------------------

-- policy: authenticated users can read all recipe ingredients
create policy "authenticated_users_can_select_recipe_ingredients"
  on content.recipe_ingredients
  for select
  to authenticated
  using (true);

-- policy: anonymous users can read all recipe ingredients
create policy "anon_users_can_select_recipe_ingredients"
  on content.recipe_ingredients
  for select
  to anon
  using (true);

-- =====================================================================
-- SECTION 7: CREATE RLS POLICIES FOR SCHEMA 'public'
-- =====================================================================
-- User data is restricted to the owning user only
-- Granular policies for each operation (SELECT, INSERT, UPDATE, DELETE)
-- =====================================================================

-- ---------------------------------------------------------------------
-- Policies for public.profiles
-- ---------------------------------------------------------------------

-- policy: users can view only their own profile
create policy "users_can_select_own_profile"
  on public.profiles
  for select
  to authenticated
  using (auth.uid() = id);

-- policy: users can insert only their own profile
-- this is typically handled by trigger, but policy ensures security
create policy "users_can_insert_own_profile"
  on public.profiles
  for insert
  to authenticated
  with check (auth.uid() = id);

-- policy: users can update only their own profile
create policy "users_can_update_own_profile"
  on public.profiles
  for update
  to authenticated
  using (auth.uid() = id)
  with check (auth.uid() = id);

-- policy: users can delete only their own profile
-- note: profile deletion will cascade from auth.users deletion
create policy "users_can_delete_own_profile"
  on public.profiles
  for delete
  to authenticated
  using (auth.uid() = id);

-- ---------------------------------------------------------------------
-- Policies for public.planned_meals
-- ---------------------------------------------------------------------

-- policy: users can view only their own planned meals
create policy "users_can_select_own_planned_meals"
  on public.planned_meals
  for select
  to authenticated
  using (auth.uid() = user_id);

-- policy: users can insert only their own planned meals
create policy "users_can_insert_own_planned_meals"
  on public.planned_meals
  for insert
  to authenticated
  with check (auth.uid() = user_id);

-- policy: users can update only their own planned meals
-- this allows marking meals as eaten and modifying ingredient overrides
create policy "users_can_update_own_planned_meals"
  on public.planned_meals
  for update
  to authenticated
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

-- policy: users can delete only their own planned meals
-- useful for regenerating meal plans or removing specific meals
create policy "users_can_delete_own_planned_meals"
  on public.planned_meals
  for delete
  to authenticated
  using (auth.uid() = user_id);

-- ---------------------------------------------------------------------
-- Policies for public.feedback
-- ---------------------------------------------------------------------

-- policy: users can view only their own feedback submissions
create policy "users_can_select_own_feedback"
  on public.feedback
  for select
  to authenticated
  using (auth.uid() = user_id);

-- policy: users can insert only their own feedback
create policy "users_can_insert_own_feedback"
  on public.feedback
  for insert
  to authenticated
  with check (auth.uid() = user_id);

-- policy: users can update only their own feedback
-- allows editing feedback before final submission if needed
create policy "users_can_update_own_feedback"
  on public.feedback
  for update
  to authenticated
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

-- policy: users can delete only their own feedback
create policy "users_can_delete_own_feedback"
  on public.feedback
  for delete
  to authenticated
  using (auth.uid() = user_id);

-- =====================================================================
-- SECTION 8: CREATE TRIGGERS
-- =====================================================================

-- ---------------------------------------------------------------------
-- Trigger function: update_updated_at_column()
-- Purpose: Automatically update updated_at timestamp on row modification
-- ---------------------------------------------------------------------
create or replace function public.update_updated_at_column()
returns trigger
language plpgsql
as $$
begin
  -- set updated_at to current timestamp
  new.updated_at = now();
  return new;
end;
$$;

comment on function public.update_updated_at_column() is 'Trigger function to automatically update updated_at column';

-- apply update_updated_at trigger to profiles table
create trigger profiles_updated_at
  before update on public.profiles
  for each row
  execute function public.update_updated_at_column();

-- apply update_updated_at trigger to recipes table
create trigger recipes_updated_at
  before update on content.recipes
  for each row
  execute function public.update_updated_at_column();

-- ---------------------------------------------------------------------
-- Trigger function: handle_new_user()
-- Purpose: Automatically create profile entry when new user signs up
-- ---------------------------------------------------------------------
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
as $$
begin
  -- create profile entry with user id and email from auth.users
  -- other fields will be filled during onboarding process
  insert into public.profiles (id, email, gender, age, weight_kg, height_cm, activity_level, goal, target_calories, target_carbs_g, target_protein_g, target_fats_g)
  values (
    new.id,
    new.email,
    'male', -- default placeholder, will be updated in onboarding
    25,     -- default placeholder, will be updated in onboarding
    70,     -- default placeholder, will be updated in onboarding
    170,    -- default placeholder, will be updated in onboarding
    'moderate', -- default placeholder, will be updated in onboarding
    'weight_loss', -- default placeholder, will be updated in onboarding
    0,      -- placeholder, will be calculated in onboarding
    0,      -- placeholder, will be calculated in onboarding
    0,      -- placeholder, will be calculated in onboarding
    0       -- placeholder, will be calculated in onboarding
  );
  return new;
end;
$$;

comment on function public.handle_new_user() is 'Trigger function to create profile entry on user signup';

-- apply handle_new_user trigger to auth.users table
create trigger on_auth_user_created
  after insert on auth.users
  for each row
  execute function public.handle_new_user();

-- ---------------------------------------------------------------------
-- Trigger function: calculate_recipe_total_calories()
-- Purpose: Denormalize total calories for recipe optimization
-- ---------------------------------------------------------------------
create or replace function content.calculate_recipe_total_calories()
returns trigger
language plpgsql
as $$
declare
  recipe_calories integer;
begin
  -- calculate total calories by summing all ingredients in the recipe
  -- this denormalization significantly improves meal replacement algorithm performance
  select sum(
    (ri.base_amount / 100.0) * i.calories_per_100_units
  )::integer into recipe_calories
  from content.recipe_ingredients ri
  join content.ingredients i on i.id = ri.ingredient_id
  where ri.recipe_id = coalesce(new.recipe_id, old.recipe_id);

  -- update the recipe's total_calories field
  update content.recipes
  set total_calories = recipe_calories
  where id = coalesce(new.recipe_id, old.recipe_id);

  return coalesce(new, old);
end;
$$;

comment on function content.calculate_recipe_total_calories() is 'Trigger function to calculate and update recipe total calories';

-- apply calculate_recipe_total_calories trigger on insert
create trigger recipe_ingredients_insert_update_calories
  after insert on content.recipe_ingredients
  for each row
  execute function content.calculate_recipe_total_calories();

-- apply calculate_recipe_total_calories trigger on update
create trigger recipe_ingredients_update_update_calories
  after update on content.recipe_ingredients
  for each row
  execute function content.calculate_recipe_total_calories();

-- apply calculate_recipe_total_calories trigger on delete
create trigger recipe_ingredients_delete_update_calories
  after delete on content.recipe_ingredients
  for each row
  execute function content.calculate_recipe_total_calories();

-- =====================================================================
-- MIGRATION COMPLETE
-- =====================================================================
-- Next steps:
-- 1. Apply migration: npx supabase db push
-- 2. Verify RLS policies: npx supabase db inspect
-- 3. Populate content.ingredients and content.recipes with seed data
-- 4. Test authentication flow and profile creation trigger
-- =====================================================================
